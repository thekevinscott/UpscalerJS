"use strict";(self.webpackChunk_upscalerjs_docs=self.webpackChunk_upscalerjs_docs||[]).push([[1784],{69910:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"welcome-upscalerjs","metadata":{"permalink":"/news/welcome-upscalerjs","source":"@site/blog/2022-08-08-new-documentation-site.md","title":"New Documentation Site","description":"We\'ve got a new documentation site for UpscalerJS","date":"2022-08-08T00:00:00.000Z","formattedDate":"August 8, 2022","tags":[{"label":"announcement","permalink":"/news/tags/announcement"}],"readingTime":0.33,"hasTruncateMarker":true,"authors":[{"name":"Kevin Scott","title":"UpscalerJS Czar","url":"https://github.com/thekevinscott","imageURL":"https://github.com/thekevinscott.png","key":"kscott"}],"frontMatter":{"title":"New Documentation Site","description":"We\'ve got a new documentation site for UpscalerJS","slug":"welcome-upscalerjs","authors":"kscott","tags":["announcement"],"hide_table_of_contents":false},"nextItem":{"title":"Revisiting Model Loading","permalink":"/news/revisiting-model-loading"}},"content":"Our new documentation site, [upscalerjs.com](https://upscalerjs.com), has just launched.\\n\\n\x3c!--truncate--\x3e\\n\\nIt\'s built on top of Docusaurus. Some of the goals for our revamped documentation include:\\n\\n* An integrated demo page\\n* Additional information on available models\\n* Integrated guides and examples\\n* A fancy homepage that makes you just wanna get started\\n\\nRebooting our docs was part of my goal to get UpscalerJS to a 1.0 release."},{"id":"revisiting-model-loading","metadata":{"permalink":"/news/revisiting-model-loading","source":"@site/blog/2022-02-03-revisiting-model-loading.md","title":"Revisiting Model Loading","description":"I posted a discussion to Github about work towards refactoring the way we load models in UpscalerJS. I\'ll repost it here for posterity.","date":"2022-02-03T00:00:00.000Z","formattedDate":"February 3, 2022","tags":[{"label":"roadmap","permalink":"/news/tags/roadmap"}],"readingTime":5.1,"hasTruncateMarker":true,"authors":[{"name":"Kevin Scott","title":"UpscalerJS Czar","url":"https://github.com/thekevinscott","imageURL":"https://github.com/thekevinscott.png","key":"kscott"}],"frontMatter":{"title":"Revisiting Model Loading","slug":"revisiting-model-loading","authors":"kscott","tags":["roadmap"],"hide_table_of_contents":false},"prevItem":{"title":"New Documentation Site","permalink":"/news/welcome-upscalerjs"},"nextItem":{"title":"1.0 Roadmap","permalink":"/news/1.0-roadmap"}},"content":"[I posted a discussion to Github about work towards refactoring the way we load models in UpscalerJS](https://github.com/thekevinscott/UpscalerJS/discussions/30). I\'ll repost it here for posterity.\\n\\n\x3c!--truncate--\x3e\\n\\nFor the 1.0 release, I\'d like to discuss, and potentially revisit, how models are configured in UpscalerJS.\\n\\n---\\n\\nThere\'s three ways a user interacts with a model in UpscalerJS:\\n\\n- No explicit model selection. (`new Upscaler()` - By default, UpscalerJS will use the `idealo/gans`, which afaik is not documented anywhere.)\\n- Explicit model selection (`new Upscaler({ model: \'div2k-2x\', scale: 2 })`)\\n- Custom model (`new Upscaler({ model: \'/path/to/custom/model\', scale: 2 })`)\\n\\nI\'d wager the majority of people go with option 1. So it makes sense to choose a sensible default that offers a good tradeoff between performance and accuracy.\\n\\nThat said, there are many valid reasons to encourage people to explore option 2, and make it easy for them to do so. Today those include:\\n\\n- **Wanting a different scale model**\\n\\nIn the near future, those include:\\n\\n- **Wanting either a _more accurate_ model than the default, or a _faster_ model than the default**. This is a little theoretical today as we only offer two flavors of models, which is a separate discussion - [how to train and include more models easily](https://github.com/thekevinscott/UpscalerJS/discussions/32) - but UpscalerJS is set up to support different model architectures, so there\'s no reason we couldn\'t have a simpler model that runs faster, or a heavier more accurate implementation.\\n- **A domain-specific model**. There\'s compelling research indicating that domain-specific models can outperform more general ones (e.g., that a model trained specifically on faces, or one trained on illustrations, can out-perform the more general use case). Being able to experiment with a \\"face\\" model, or an \\"illustration\\" model, could be very nice. \\n- **Different channeled models**. There\'s [been an ask for models](https://github.com/thekevinscott/UpscalerJS/issues/8) that operate in different _channels_ - aka, supporting transparency. I also think a grayscale version would be interesting to explore as it\'d likely be a much faster model operating on a single channel.\\n\\nToday, if a user wants to see what models are available, they can either call `getModelDefinitions` from within the package, or they\'re directed to this second repo - https://github.com/thekevinscott/UpscalerJS-models. The reason models live in a separate repo is because of size. Models must be served over the web (aka, not packaged) so we serve them via a CDN. Including these in the core npm library would bloat its download size significantly, which would be particularly frustrating given most users would only need a single model.\\n\\nThat said, that particular repo is missing the default model used (idealo/gans) and doesn\'t provide a good way of experimenting with models to see how they perform with real world data. It\'s also hard to keep the two repos up to date (because the core UpscalerJS library must maintain references to the upscalerjs-models repo).\\n\\n--- \\n\\nA word on models and their configuration.\\n\\nTo me, a model encompasses the following:\\n\\n- A particular architecture, or algorithm - for instance, [ESRGAN](https://arxiv.org/abs/1809.00219)\\n- A particular implementation of that architecture - for instance, [idealo\'s implementation of ESRGAN](https://github.com/idealo/image-super-resolution)\\n- The dataset used to train that model - for instance, [DIV2K](https://data.vision.ee.ethz.ch/cvl/DIV2K/)\\n- The scale the model is trained at - 2, 3, 4\\n- _Train-time_ related configuration that can affect inference configuration - for instance, number of supported channels, which would need to be chosen correctly in order to support specific images\\n- _Train-time_ related configuration that can affect performance - for instance, pruning strategy, along with more architecture-specific training settings such as G and G0 ([as illustrated here](https://github.com/idealo/image-super-resolution#training))\\n- _Compile-time_ related configuration, such as quantization amount, which could affect performance\\n\\nThe end result of all of this configuration is a single model file.\\n\\n---\\n\\nLet\'s talk questions:\\n\\n- If you\'re _not_ using the default model today, how did you find, explore, and choose the model you\'re using?\\n- What\'s the right place to find and explore available models? In the README? In the documentation page? On a dedicated models page, or dedicated repo? All three?\\n- What\'s an ergonomic way of choosing a model? Should models have simple-to-understand names (aka, `face-2x-grayscale`), or should they be more verbose, reflecting their underlying configuration (e.g., `esrgan-idealo-div2k-2-1-channel`, or `esrgan/idealo/div2k/2/1-channel`)? If the former, where and how would a user learn more information about the particular model (how it was trained, how to reproduce the results)? If the latter, how do we form that string to effectively communicate the model\'s configuration?\\n- Similar to the above - is it better to specify a single path to a model, or is it better to pass an object denoting that model, something like `{ dataset: \'DIV2K\', scale: 2, channels: 4 }`? If the latter, how do we handle cases where we don\'t have a model for a particular configuration?\\n- Is a _runtime_ method useful for returning information about the model? Or will users only be interacting with these things when developing their software (aka, we can communicate a model\'s configuration offline)?\\n\\nMy top-level thoughts:\\n- Making it easy to keep models up-to-date and in-sync is good. I wonder if we could bring the models back into this repo, and use something like `lerna` to publish two npm packages from this single repo.\\n- Redundancy of documentation is probably good (aka, showing information about the models in multiple places is fine, as people get their documentation from all kinds of places).\\n- Live interaction in real time is best; there should be a tool that allows for experimentation with different models in real time, that also generates instantiation code for you.\\n\\nCurious to hear from others on your thoughts!\\n\\n----\\n\\nUPDATE (2/3/22)\\n\\nSome updates since I wrote this post:\\n\\n> Making it easy to keep models up-to-date and in-sync is good. I wonder if we could bring the models back into this repo, and use something like lerna to publish two npm packages from this single repo.\\n\\nThis is now done. Models live in the repo and are published as a separate package on NPM.\\n\\n[I also set out a roadmap](https://github.com/thekevinscott/UpscalerJS/discussions/163) that includes Node support as a precursor, so that\'s another thing worth considering in this discussion."},{"id":"1.0-roadmap","metadata":{"permalink":"/news/1.0-roadmap","source":"@site/blog/2022-01-23-1.0-roadmap.md","title":"1.0 Roadmap","description":"Detailing our roadmap towards 1.0","date":"2022-01-23T00:00:00.000Z","formattedDate":"January 23, 2022","tags":[{"label":"roadmap","permalink":"/news/tags/roadmap"}],"readingTime":0.45,"hasTruncateMarker":true,"authors":[{"name":"Kevin Scott","title":"UpscalerJS Czar","url":"https://github.com/thekevinscott","imageURL":"https://github.com/thekevinscott.png","key":"kscott"}],"frontMatter":{"title":"1.0 Roadmap","description":"Detailing our roadmap towards 1.0","slug":"1.0-roadmap","authors":"kscott","tags":["roadmap"],"hide_table_of_contents":false},"prevItem":{"title":"Revisiting Model Loading","permalink":"/news/revisiting-model-loading"}},"content":"[I posted a discussion to Github about our upcoming 1.0 roadmap](https://github.com/thekevinscott/UpscalerJS/discussions/163). I\'ll repost it here for posterity.\\n\\n\x3c!--truncate--\x3e\\n\\n* `0.9` - A clean up release, primarily bumping versions to the latest across the board\\n* `0.10` - First class Node support\\n* `0.11` - A reboot of model loading and model configurations\\n\\nNode support is a feature the community has been asking for. [The relevant Github issue tracking that is here](https://github.com/thekevinscott/UpscalerJS/issues/11).\\n\\nAlong with Node support, revisiting the way models are loaded in UpscalerJS is next on our road to 1.0."}]}')}}]);